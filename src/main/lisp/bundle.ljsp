;-*- Mode: Lisp -*-

(+ 1 1)

;; Bootstrapping: begin!
;; IMPLEMENTED USING ONLY PRIMITIVES
(set (quote defun)
     (macro (a)
       (cons (quote set) (cons (cons (quote quote) (cons (car (cdr a)) nil)) (cons (cons (quote lambda) (cdr (cdr a))) nil)))))

;; IMPLEMENTED USING ONLY PRIMITIVES
(set (quote defmacro)
     (macro (a)
       (cons (quote set) (cons (cons (quote quote) (cons (car (cdr a)) nil)) (cons (cons (quote macro) (cdr (cdr a))) nil)))))

(defun %load-loop (stream)
  (if (eof? stream)
      t
      ((lambda () (eval (read stream))
                  (%load-loop stream)))))

(defun load (file)
  ((lambda (stream)
     (%load-loop stream)
     (close stream))
   (open file 'in)))

(defun 1- (n) (- n 1))
(defun 1+ (n) (+ n 1))

(defun terpri rst
  (write-char #\
              (car rst))
  nil)

(defun print (obj . rst)
  (prin1 obj (car rst))
  (terpri (car rst))
  obj)

(defun displace (old new)
  (rplaca old (car new))
  (rplacd old (cdr new)))

(defun error (str) (throw 'simple-error str)) ; Make me better, more like CL I guess.

(defun end? (lst)
  (if (atom? lst)
      (if lst
          (error "Not list!")
          t)
      nil))

(defun not (obj) (eq? obj nil))
(set (quote null?) not)
(defun cons? (obj) (not (atom? obj)))
(defun list? (lst)
  (if (atom? lst)
      (if lst nil t)
      t))
(defun zero? (n) (= n 0))
(defun pos? (n) (if (zero? n) nil (not (neg? n))))
(defun /= (a b) (not (= a b)))
(defun < (a b) (neg? (- a b)))
(defun > (a b) (neg? (- b a)))
(defun <= (a b) (if (= a b) t (< a b)))
(defun >= (a b) (if (= a b) t (> a b)))

(defun list lst lst)

(defun list* (arg . others)
  (if (null? others)
      arg
      (if (null? (cdr others))
          (cons arg (car others))
          ((lambda (roop)
             (roop others)
             (cons arg others))
           (lambda (x)
             (if (null? (cdr (cdr x)))
                 (rplacd x (car (cdr x)))
                 (roop (cdr x))))))))

(defmacro progn (a) (displace a
  (list (list* (quote lambda) () (cdr a)))))

(defun reverse (lst)
  ((lambda (rev) (rev lst nil))
   (lambda (lst acc)
     (if (end? lst)
         acc
         (rev (cdr lst) (cons (car lst) acc))))))

(set 'reverse! reverse)                 ; TODO: Implement actual reverse!

(defmacro setq (a) (displace a
  ((lambda (frob) (cons (quote progn) (frob (cdr a) nil)))
   (lambda (lst acc)
     (if (end? lst)
         (reverse! acc)
         (frob (cdr (cdr lst))
               (cons (list (quote set) (list (quote quote) (car lst)) (car (cdr lst))) acc)))))))

(defun nthcdr (n lst)
  (if (zero? n)
      lst
      (nthcdr (- n 1) (cdr lst))))

(defun nth (n lst) (car (nthcdr n lst)))

;; (defun length (lst)
;;   ((lambda (len) (len lst 0))
;;    (lambda (lst acc)
;;      (if (end? lst)
;;          acc
;;          (len (cdr lst) (+ acc 1))))))

(defun caar (x) (car (car x)))
(defun cadr (x) (car (cdr x)))
(defun cdar (x) (cdr (car x)))
(defun cddr (x) (cdr (cdr x)))
(defun caaar (x) (car (car (car x))))
(defun caadr (x) (car (car (cdr x))))
(defun cadar (x) (car (cdr (car x))))
(defun caddr (x) (car (cdr (cdr x))))
(defun cdadr (x) (cdr (car (cdr x))))
(defun cddar (x) (cdr (cdr (car x))))
(defun cdddr (x) (cdr (cdr (cdr x))))
(defun caaaar (x) (car (car (car (car x)))))
(defun caaadr (x) (car (car (car (cdr x)))))
(defun caadar (x) (car (car (cdr (car x)))))
(defun caaddr (x) (car (car (cdr (cdr x)))))
(defun cadaar (x) (car (cdr (car (car x)))))
(defun cadadr (x) (car (cdr (car (cdr x)))))
(defun caddar (x) (car (cdr (cdr (car x)))))
(defun cadddr (x) (car (cdr (cdr (cdr x)))))
(defun cdaaar (x) (cdr (car (car (car x)))))
(defun cdaadr (x) (cdr (car (car (cdr x)))))
(defun cdadar (x) (cdr (car (cdr (car x)))))
(defun cdaddr (x) (cdr (car (cdr (cdr x)))))
(defun cddaar (x) (cdr (cdr (car (car x)))))
(defun cddadr (x) (cdr (cdr (car (cdr x)))))
(defun cdddar (x) (cdr (cdr (cdr (car x)))))
(defun cddddr (x) (cdr (cdr (cdr (cdr x)))))
(setq rest   cdr
      first  car
      second cadr
      third  caddr
      fourth cadddr)
(defun fifth   (x) (nth 5 x))
(defun sixth   (x) (nth 6 x))
(defun seventh (x) (nth 7 x))
(defun eigth   (x) (nth 8 x))
(defun ninth   (x) (nth 9 x))
(defun tenth   (x) (nth 10 x))

;; KLUDGE: Hinges on dynamic scoping (bad if I decide to change this in the future)
;; Currently variables are evaluated in backwards order, but this is currently not a problem
(defmacro let (a) (displace a
  ((lambda (vars var-args parse-bindings)
     (setq vars nil)
     (setq var-args nil)
     (parse-bindings (cadr a))
     (cons (cons (quote lambda) (cons vars (cddr a)))
           var-args))
   nil
   nil
   (lambda (lst)
     (if (end? lst)
         nil
         ((lambda ()
            (if (list? (car lst))
                ((lambda ()
                   (setq vars (cons (caar lst) vars))
                   (setq var-args (cons (cadar lst) var-args))))
                ((lambda ()
                   (setq vars (cons (car lst) vars))
                   (setq var-args (cons nil var-args)))))
            (parse-bindings (cdr lst)))))))))

(defmacro let* (a) (displace a
  (let ((clauses (cadr a))
        (body    (cddr a))
        (generate-lets (lambda (lst acc)
                         (if (end? lst)
                             (car acc)
                             (generate-lets (cdr lst) (list (list* 'let (list (car lst)) acc)))))))
    (generate-lets (reverse clauses) body))))

(defmacro when (a)
  (let ((test (cadr a))
        (body (cddr a)))
    (list (quote if) test (cons (quote progn) body))))

(defmacro unless (a)
  (let ((test (cadr a))
        (body (cddr a)))
    (list (quote if) (list (quote not) test) (cons (quote progn) body))))

(if (running-compiled?)
    nil                       ; define letrec compatible with compiler
    (setq letrec let*))       ; as far as the dynamically scoped interpreter goes punning letrec to let* ought to do it

(defmacro cond (a) (displace a
  (let ((clauses (cdr a)))
    (if (end? clauses)
        nil
        (let ((clause (first clauses))
              (more (rest clauses)))
          (if (atom? clause)
              (error "Clause not list!")
              (let ((test (first clause))
                    (forms (rest clause)))
                (if (end? forms)
                    (let ((n-result (gensym)))
                      (list (quote let) (list (list n-result test))
                            (list (quote if) n-result
                                  n-result
                                  (cons (quote cond) more))))
                    (if (eq? t test)
                        (cons (quote progn) forms)
                        (list (quote if) test
                              (cons (quote progn) forms)
                              (when more (cons (quote cond) more))))))))))))


(defun reduce (fn lst)
  (let ((roop (lambda (fn lst acc)
                (if (end? lst)
                    acc
                    (roop fn (cdr lst) (fn acc (car lst)))))))
    (roop fn (cdr lst) (car lst))))

;; Make arithmetics awesomer
;; Speed impact: ginormous
;; Better do this in java...
(setq i-like-slow nil)
(when i-like-slow
  (setq binary+ +
        binary- -
        binary* *
        binary/ /)

  (defun + numbers
    (if (null? numbers)
        0
        (reduce binary+ numbers)))
  
  (defun - (number . more-numbers)
    (if (null? more-numbers)
        (binary- 0 number)
        (reduce binary- (cons number more-numbers))))

  (defun * numbers
    (if (null? numbers)
        1
        (reduce binary* numbers)))

  (defun / (number . more-numbers)
    (if (null? more-numbers)
        (/ 1 number)
        (reduce binary/ (cons number more-numbers)))))


;; Kinda icky to use due to dynamic scoping
(defun remove-if (fn lst)
  (let ((rem (lambda (fn lst acc)
               (cond ((end? lst)     (reverse! acc))
                     ((fn (car lst)) (rem fn (cdr lst) acc))
                     (t              (rem fn (cdr lst) (cons (car lst) acc)))))))
    (rem fn lst nil)))

(defun append lsts
  (let ((%append (lambda (x y)          ; NOT TAIL RECURSIVE
                   (cond ((null? x) y)
                         (t (cons (car x) (append (cdr x) y)))))))
    (reduce %append lsts)))

(defun flatten (lst)                   
  (cond ((null? lst) nil)
        ((atom? lst) (list lst))
        (t (append (flatten (car lst))
                   (flatten (cdr lst))
                   nil))))

(defun remove (item lst . rst)
  (let* ((test (car rst))
         (test (if test test eql?))
         (rem (lambda (item lst test acc)
                (cond ((end? lst)            (reverse! acc))
                      ((test (car lst) item) (rem item (cdr lst) test acc))
                      (t                     (rem item (cdr lst) test (cons (car lst) acc)))))))
    (rem item lst test nil)))

(defun %getf-helper (place indicator default)
  (cond ((end? place)                default)
        ((eq? indicator (car place)) place)
        (t                           (%getf-helper (cddr place) indicator default))))

(defun getf (place indicator . rst)
  (let* ((sym (gensym)) ; This is a leading cause of excessive gensymmage. Try storing it globally or so instead.
         (lst (%getf-helper place indicator sym)))
    (if (eq? lst sym)
        (car rst)                       ; default-value
        (second lst))))
    
(defun %putf-helper (place indicator value)
  (let* ((sym (gensym)) ; This is a leading cause of excessive gensymmage. Try storing it globally or so instead.
         (lst (%getf-helper place indicator sym)))
    (if (eq? lst sym)
        (list* indicator value place)
        (progn (rplaca (cdr lst) value) place))))


;; UNHYGIENIC?
(defmacro putf (a)
  (let ((place     (second a))
        (indicator (third a))
        (value     (fourth a)))
    (list 'setq place
          (list '%putf-helper place indicator value))))

;; So apply isn't primitive in this lisp...
(defun apply (fn . args)
  (let* ((add-quotes (lambda (lst)      ; NOT TAIL RECURSIVE
                       (if (end? lst)
                           nil
                           (cons (list 'quote (car lst)) (add-quotes (cdr lst))))))
         (roop (lambda (lst)            ; NOT TAIL RECURSIVE
                 (if (end? (cdr lst))
                     (car lst)
                     (cons (car lst) (roop (cdr lst))))))
         (args (add-quotes (if (cdr args)
                               (roop args)
                               (car args)))))
    (eval (cons fn args))))

(defun subst-symbols (tree . replacings)
  (if (atom? tree)
      (let* ((sym (gensym)) ; This is a leading cause of excessive gensymmage. Try storing it globally or so instead.
             (x (getf replacings tree sym)))
        (if (eq? x sym) tree x))
      (cons (apply subst-symbols (car tree) replacings)
            (apply subst-symbols (cdr tree) replacings))))

;; Substitute matches in tree with gensyms
(defun subst-with-gensyms (tree . symbols)
  (let ((generate-substitutions
         (lambda (lst acc)
           (if (end? lst)
               acc
               (generate-substitutions (cdr lst) (list* (car lst) (gensym) acc))))))
    (apply subst-symbols tree (generate-substitutions symbols nil))))

(defmacro and (a)
  (let ((forms (cdr a)))
    (cond ((end? forms)        t)
          ((end? (rest forms)) (first forms))
          (t (subst-symbols '(if <test>
                               (and . <rest>)
                               nil)
                            '<test> (first forms)
                            '<rest> (rest forms))))))

(defmacro or (a) 
  (let ((forms (cdr a)))
    (cond ((end? forms) nil)
          ((end? (rest forms)) (first forms))
          (t (subst-symbols '(let ((<n-result> <first>))
                               (if <n-result>
                                   <n-result>
                                   (or . <rest>)))
                            '<n-result> (gensym)
                            '<first>    (first forms)
                            '<rest>     (rest forms))))))



;; Finds what variables are (re)bound in sexp
;; FIXME: borkorod it seems
(defun walk-for-rebinding (sexp . acc)
  (let ((acc (car acc)))
    (let ((handle-let (lambda (lst acc) ; lst <- the bindings argument of let
                        (cond ((end? lst) acc)
                              ((atom? (car lst)) (handle-let (cdr lst) (cons (car lst) acc)))
                              (t (handle-let (cdr lst) (cons (caar lst) acc))))))
          (handle-lambda (lambda (lst acc) ; lst <- the variable list of lambda
                           (if (atom? lst)
                               (if (null? lst)
                                   acc
                                   (cons lst acc)) ; we had a dotted list
                               (handle-lambda (cdr lst) (cons (car lst) acc))))))
      (cond ((atom? sexp) acc)
            ((eq? (car sexp) 'lambda) (walk-for-rebinding ; should handle flambda and macro the same way
                                       (cdr sexp)
                                       (walk-for-rebinding
                                        (cddr sexp)
                                        (handle-lambda (cadr sexp) acc))))
            ((eq? (car sexp) 'let) (walk-for-rebinding
                                    (cdr sexp)
                                    (walk-for-rebinding
                                     (cddr sexp)
                                     (handle-let (cadr sexp) acc))))
            (t (walk-for-rebinding (cdr sexp) acc))))))

(defmacro defun. (a)
  (let ((name      (cadr  a))
        (variables (caddr a))
        (body      (cdddr a)))
    (let ((generate-substitutions       ; PROBABLY TAIL RECURSIVE
           (lambda (lst acc)
             (if (atom? lst)
                 (if (null? lst)
                     acc
                     (list* lst (gensym) acc)) ; we had a dotted list
                 (generate-substitutions (cdr lst) (list* (car lst) (gensym) acc))))))
      (list 'setq name (apply subst-symbols (list* 'lambda variables body)
                              (generate-substitutions variables nil))))))

(defmacro lambda. (a) (displace a
  (let ((generate-substitutions       ; PROBABLY TAIL RECURSIVE
         (lambda (lst acc)
           (if (atom? lst)
               (if (null? lst)
                   acc
                   (list* lst (gensym) acc)) ; we had a dotted list
               (generate-substitutions (cdr lst) (list* (car lst) (gensym) acc))))))
      (cons 'lambda (apply subst-symbols (cdr a)
                           'lambda 'lambda.
                           'let    'let.
                           (generate-substitutions (cadr a) nil))))))

(defmacro let. (a) (displace a
  (let ((generate-substitutions
         (lambda (lst acc)
           (cond ((null? lst) acc)
                 ((atom? (car lst)) (generate-substitutions (cdr lst) (list* (car lst) (gensym) acc)))
                 (t                 (generate-substitutions (cdr lst) (list* (caar lst) (gensym) acc)))))))
      (cons 'let (apply subst-symbols (cdr a)
                        'lambda 'lambda.
                        'let    'let.
                        (generate-substitutions (cadr a) nil))))))

;; TODO: depends on let. and lambda., should it?
;; Like defun but avoids capturing variables. Uses gensyms to have
;; "private" argument identifiers, sort-of solves the downward funargs problem.
(defmacro defun. (a)
  (let ((name (cadr a))
        (rst  (cddr a)))
    (list 'setq name (subst-symbols (cons 'lambda. rst)
                                    'lambda 'lambda.
                                    'let 'let.))))

;; this evaluates everything in a lambda expression beforehand
;; except for the arguments, basically generating a closure.
;; This is a mess, seriously, maybe I should just implement passable environments, maybe i should just
;; go lexical scoping which is the right way anyway.
;; FIXME: This is broken too.
;; (defun. function (fn)
;;   (let ((variables (cadr fn))
;;         (body      (cddr fn)))
;;     (let ((generate-substitutions
;;            (lambda (lst acc)
;;              (if (end? lst)
;;                  acc
;;                  (generate-substitutions (cdr lst)
;;                                          (list* (car lst)
;;                                                 (list 'quote (symbol-value (car lst)))
;;                                                 acc))))))
;;       (list* 'lambda. variables (apply subst-symbols body
;;                                        (generate-substitutions
;;                                         (remove-if (lambda (x) (not (some (lambda (y) (eq? x y)) variables))) ; BAD BAD BAD
;;                                                    (flatten body))
;;                                         nil))))))
    
                     
(defun %time (fn)
  (let ((t0 (get-time)) result time)
    (set 'result (fn))
    (set 'time (- (get-time) t0))
    (write-string "Execution time: ")
    (prin1 time)
    (write-string " ms")
    (terpri)
    result))

(defmacro time (a)
  (list '%time (list* 'lambda '() (cdr a))))

(defun. call-times (count fn)
  (let ((count-minus-one (- count 1))
        (roop (lambda (i)
                (if (= i count-minus-one)
                    (fn i)
                    (progn
                      (fn i)
                      (roop (+ i 1)))))))
    (roop 0)))

(defmacro dotimes (a) (displace a
  (let* ((var-count-result (cadr a))
         (body             (cddr a))
         (var    (first  var-count-result))
         (count  (second var-count-result))
         (result (third  var-count-result)))
    (list 'progn (list 'call-times count (list* 'lambda (list var) body))
          result))))
    

(defun call-for-list (lst fn)
  (cond ((end? (cdr lst)) (fn (car lst)))
        (t                (fn (car lst))
                          (call-for-list (cdr lst) fn))))
;; KLUDGE: Since I use dynamic scoping in my lisp I'm forced to use gensyms for the
;;         variables of some functions accepting functions. (NOTE: dynamic scoping, while easy to implement,
;;         is a twisty maze of symbols all alike)
;;         But closures might just be doable with dynamic scoping anyhow hmm
(defun. call-for-list (lst fn)
  (cond ((end? lst)       nil)
        ((end? (cdr lst)) (fn (car lst)))
        (t                (fn (car lst))
                          (call-for-list (cdr lst) fn))))
                     
;; (let ((lst-sym (gensym))
;;       (fn-sym  (gensym)))
;;   (setq call-for-list (list 'lambda (list lst-sym fn-sym)
;;                             (list 'cond
;;                                   (list (list 'end? (list 'cdr lst-sym))
;;                                         (list fn-sym (list 'car lst-sym)))
;;                                   (list 't
;;                                         (list fn-sym (list 'car lst-sym))
;;                                         (list 'call-for-list (list 'cdr lst-sym) fn-sym))))))

(defmacro dolist (a) (displace a
  (let ((var-lst-result (cadr a)))                               
    (subst-symbols '(progn
                      (call-for-list <lst> (lambda (<var>) . <body>))
                      <result>)
     '<var>    (first  var-lst-result)
     '<lst>    (second var-lst-result)
     '<result> (third  var-lst-result)
     '<body>   (cddr a)))))
                 
;; (defmacro dolist (a) (displace a
;;   (let* ((var-lst-result (cadr a))
;;          (body           (cddr a))
;;          (var    (first  var-lst-result))
;;          (lst    (second var-lst-result))
;;          (result (third  var-lst-result)))
;;     (list 'progn (list 'call-for-list lst (list* 'lambda (list var) body))
;;           result))))

(defun mapcar (fn lst)
  ((lambda (mapcar-helper) (mapcar-helper fn lst nil))
   (lambda (fn lst acc)
     (if (end? lst)
         acc
         (mapcar-helper fn (cdr lst) (cons (fn (car lst)) acc))))))

;; NOT TAIL RECURSIVE
(defun mapcar1 (fnx lstx)
  (if (end? lstx)
      nil
      (cons (fnx (car lstx)) (mapcar1 fnx (cdr lstx)))))

(defun some (predicate . sequences)
  (cond ((if (= (length sequences) 1)
             (end? (car sequences))
             (some end? sequences)) nil)
        ((apply predicate (mapcar1 car sequences)))
        (t (apply some predicate (mapcar1 cdr sequences)))))

;; NOT TAIL RECURSIVE
(defun mapcar (fnx . lstsx)
  (if (some end? lstsx)
      nil
      (cons (apply fnx (mapcar1 car lstsx)) (apply mapcar fnx (mapcar1 cdr lstsx)))))

;; ;; NOT TAIL RECURSIVE
;; ;; copies only surface layer
;; (defun copy-list (lst)
;;   (if (end? lst)
;;       nil
;;       (cons (car lst) (copy-list (cdr lst)))))

;; NOT TAIL RECURSIVE
(defun copy-list (lst)
  (if (atom? lst)
      lst
      (cons (copy-list (car lst)) (copy-list (cdr lst)))))

;; TODO: write find working on sequences?
(defun member (item lst)
  (cond ((end? lst)            nil)
        ((eql? item (car lst)) lst)
        (t                     (member item (cdr lst))))) 

(defun acons (key value alist) (cons (cons key value) alist))

(defun pairlis (keys data . rst)
  (let ((alist (car rst)))
    (append (mapcar (lambda (x y) (cons x y)) keys data) alist)))

;; ADD OPTIONAL COMPARE FN
(defun assoc (key alist)
  (cond ((end? alist)            nil)
        ((eql? key (caar alist)) (car alist))
        (t                       (assoc key (cdr alist)))))

;; ADD OPTIONAL COMPARE FN
(defun rassoc (key alist)
  (cond ((end? alist)            nil)
        ((eql? key (cdar alist)) (car alist))
        (t                       (rassoc key (cdr alist)))))

(defun assq (key alist)
  (cond ((end? alist)           nil)
        ((eq? key (caar alist)) (car alist))
        (t                      (assq key (cdr alist)))))

(defun rassq (key alist)
  (cond ((end? alist)           nil)
        ((eq? key (cdar alist)) (car alist))
        (t                      (rassq key (cdr alist)))))
         
(let ((definer (macro (a)
                 (subst-symbols '(defmacro <name> (a)
                                   (subst-symbols '(setq <place> (<fun> <place> <delta>))
                                                  '<place> (second a)
                                                  '<delta> (if (third a) (third a) 1)))
                                  '<name> (second a)
                                  '<fun>  (third a)))))
  (definer inc +)
  (definer dec -))

(defmacro push (a)
  (subst-symbols '(setq <place> (cons <obj> <place>))
                 '<obj>   (second a)
                 '<place> (third a)))

(defmacro pop (a)
  (subst-symbols '(let ((<save> (car <place>)))
                    (setq <place> (cdr <place>))
                    <save>)
                 '<save>  (gensym)
                 '<place> (second a)))

;; UNHYGIENIC?
;; (defmacro push (a)
;;   (let ((obj   (second a))
;;         (place (third a)))
;;     (list 'setq place (list 'cons obj place))))

;; UNHYGIENIC?
;; (defmacro pop (a)
;;   (let ((save-sym (gensym))
;;         (lst-var  (second a)))
;;     (list (quote let) (list (list save-sym (list (quote car) lst-var)))
;;           (list (quote setq) lst-var (list (quote cdr) lst-var))
;;           save-sym)))

(defun macroexpand (form)
  (let ((mac (eval (first form))))
    (cond ((eq? (first mac) (quote macro))
           (let ((macro-fn (cons (quote lambda) (cdr mac))))
             (eval (list macro-fn (list (quote quote) form)))))
          (t (error "I-liek-the-first-thing-to-be-a-macro-for-now")))))

;; (defun factorial (n)
;;   (if (zero? n)
;;       1
;;       (* n (factorial (- n 1)))))

(defun factorial (n)
  (let ((fact (lambda (n acc)
                (if (zero? n)
                    acc
                    (fact (- n 1) (* n acc))))))
    (fact n 1)))

(defun fib (n)
  (if (= n 0)
      0
      (if (= n 1)
          1
          (+ (fib (- n 1)) (fib (- n 2))))))

(defun fib-trec (n)
  ((lambda (calc-fib) (calc-fib n 0 1))
   (lambda (n a b)
     (if (= n 0)
         a
         (calc-fib (- n 1) b (+ a b))))))

(setq fib-memo-table (quote ((0 . 0) (1 . 1))))
(defun fib-memo (n)
  (let ((ass (assoc n fib-memo-table)))
    (if ass
        (cdr ass)
        (let ((result (+ (fib-memo (- n 1)) (fib-memo (- n 2)))))
          (setq fib-memo-table (acons n result fib-memo-table))
          result))))

(setq foo-memo-table (quote ((0 . 0) (1 . 1))))
(defun foo-memo (n)
  (let ((ass (assoc n foo-memo-table)))
    (if ass
        (cdr ass)
        (let ((result (- (* 5 (foo-memo (- n 1))) (* 6 (foo-memo (- n 2))))))
          (setq foo-memo-table (acons n result foo-memo-table))
          result))))


(defun memoize-fn (fn-name)
  (let ((table-sym (gensym))
        (ass-sym   (gensym))
        (arg-sym   (gensym))
        (args-sym  (gensym))
        (fn (symbol-value fn-name)))
    (set table-sym nil)
    (set fn-name
         (subst-symbols
          '(lambda (<arg-sym> . <args-sym>)
             (let ((<args-sym> (cons <arg-sym> <args-sym>)))
               (let ((<ass-sym> (assoc <args-sym> <table-sym> equal)))
                 (if <ass-sym>
                     (cdr <ass-sym>)
                     (let ((result (apply <fn> <args-sym>)))
                       (setq <ass-sym> (acons <args-sym> result <table-sym>))
                       result)))))
          '<arg-sym> arg-sym
          '<args-sym> args-sym
          '<ass-sym> ass-sym
          '<table-sym> table-sym
          '<fn> fn))))
  
(defun collatz (n)
  (print n)
  (if (= n 1)
      nil
      (collatz (if (= (mod n 2) 0)
                   (/ n 2)
                   (+ 1 (* n 3))))))

(defun is-prime (n)
  (let ((roop (lambda (a)
                (cond ((= a n)            t)
                      ((zero? (mod n a)) nil)
                      (t                 (roop (+ a 2)))))))
  (cond ((= n 1) nil)
        ((= n 2) t)
        ((zero? (mod n 2)) nil)
        (t (roop 3)))))

(defun wn-zero? (n) (not n))
(defun wn1+ (n) (cons nil n))
(defun wn1- (n) (cdr n))

(defun to-wn (n)
  (let ((roop (lambda (n acc)
                (if (zero? n)
                    acc
                    (roop (- n 1) (wn1+ acc))))))
    (roop n nil)))

(defun wn+ (n1 n2)
  (if (wn-zero? n2)
      n1
      (wn+ (wn1+ n1) (wn1- n2))))

(defun wn- (n1 n2)
  (if (wn-zero? n2)
      n1
      (wn- (wn1- n1) (wn1- n2))))

(defun wn* (n1 n2)
  (let ((roop (lambda (a b)
                (if (wn-zero? b)
                    a
                    (roop (wn+ a n1) (wn1- b))))))
    (roop n1 (wn1- n2))))
    
(defun factorial-wn (n)
  (let ((fact (lambda (n acc)
                (if (wn-zero? n)
                    acc
                    (fact (wn1- n) (wn* n acc))))))
    (fact n (wn1+ nil))))

(defmacro backwards (a)
  (print (quote expanding-macaroni))
  (displace a
            (reverse (cadr a))))

(defun cond-test (a)
  (cond ((= a 3) (* a 2))
        ((= a 5) (/ a 2))
        (t       (* a 3))))

;; ;; TODO: Optional stream param
;; (defun read-string ()
;;   (let ((roop (lambda (acc)
;;                 (let ((char (read-char)))
;;                   (if (= char #\
;;                          )
;;                       (reverse acc)
;;                       (roop (cons char acc)))))))
;;     (roop nil)))

;; (defun read-string rst
;;   (let ((stream (if (first rst)
;;                     (first rst)
;;                     *standard-input*)))
    
                    

;; ;; TODO: Optional stream param
;; (defun write-string (str)
;;   (cond ((end? str) nil)
;;         (t          (write-char (car str))
;;                     (write-string (cdr str)))))
(defun write-string (str . rst)
  (let ((stream (if rst (car rst) *standard-output*)))
    (dotimes (i (length str))
      (write-char (aref str i) stream))))

(defun generate-ascii-table (listfist)
  (let ((roop (lambda (lst i acc)
                (if (end? lst)
                    acc
                    (roop (cdr lst) (+ i 1) (acons (car lst) i acc))))))
    (roop listfist 0 nil)))

(setq ascii-table (generate-ascii-table
                   '(NUL SOH STX ETX EOT ENQ ACK BEL BS TAB LF VT FF CR SO SI DLE DC1
                     DC2 DC3 DC4 NAK SYN ETB CAN EM SUB ESC FS GS RS US | | !
                     |"| |#| $ % & |'| |(| |)| * + , - |.| / 0 1 2 3 4 5 6 7 8 9
                     : |;| < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W
                     X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w
                     x y z { || } ~ DEL)))

(defun to-string (lst)
  (let ((roop (lambda (lst acc)
                (if (end? lst)
                    (reverse acc)
                    (roop (cdr lst) (cons (cdr (assoc (car lst) ascii-table)) acc))))))
    (roop lst nil)))

(defun from-string (lst)
  (let ((roop (lambda (lst acc)
                (if (end? lst)
                    (reverse acc)
                    (roop (cdr lst) (cons (car (rassoc (car lst) ascii-table)) acc))))))
    (roop lst nil)))

;; ;; Use varargs instead, when you get it 
;; (defmacro make-list (a)
;;   (list '%make-list (cadr a) (caddr a)))

(defun make-list (size . initial-element)
  (let ((initial-element (car initial-element))
        (listmaker (lambda (n acc)
                     (if (zero? n)
                         acc
                         (listmaker (- n 1) (cons initial-element acc))))))
    (listmaker size nil)))

(defun make-graph (n) (cons 'graph (make-list n)))

(defun graph? (obj) (eq? (car obj) 'graph))

(defun graph-add-edge (graf from to)
  (unless (graph? graf)
    (error "Not graph"))
  (let ((f (+ from 1))
        (t (+ to 1)))
    (rplaca (nthcdr f graf) (cons to   (nth f graf))) ;Inefficient as hell this is
    (rplaca (nthcdr t graf) (cons from (nth t graf))))
  graf)

(defun graph-num-vertices (graf)
  (unless (graph? graf)
    (error "Not graph"))
  (- (length graf) 1))

(defun graph-get-adjacent-edges (graf v) (nth (+ v 1) graf))

(defun depth-first-search (graf a fn)
  (unless (graph? graf)
    (error "Not graph"))
  (let ((visited (make-list (graph-num-vertices graf) nil))
        (dfs     (lambda (a)
                   (unless (nth a visited)  ;Inefficient (I might just need arrays in this lisp)
                     (rplaca (nthcdr a visited) t)
                     (fn graf a)
                     ;; Och här slår man i problemen med dynamic scoping. call-for-list har en parameter vid namn fn
                     (call-for-list (graph-get-adjacent-edges g a) dfs)))))
    (dfs a)))

(defun gcd (a b)
  (if (zero? b)
      a
      (gcd b (- a (* b (/ a b))))))

(defun read-from-string (str)
  (let ((stream (make-string-input-stream str)))
    (read stream)))

(defmacro with-output-to-string (a) (displace a
  (subst-symbols '(let ((<var> (make-string-output-stream)))
                    <body>
                    (get-output-stream-string <var>))
                 '<var>  (if (atom? (cadr a)) (cadr a) (caadr a)) ; Continue supporting alternate syntax (with-output-to-string stream blah) ?
                 '<body> (list* 'progn (cddr a)))))

(defmacro with-open-file (a)
  (subst-symbols '(let* ((<stream> (open <file> '<direction>))
                         (<result> (progn . <body>)))
                      (close <stream>)
                      <result>)
                 '<stream> (caadr a)
                 '<file> (cadadr a)
                 '<direction> (caddr (cadr a))
                 '<result> (gensym)
                 '<body> (cddr a)))
  

(defun prin1-to-string (obj)
  (with-output-to-string (stream)
    (prin1 obj stream)))

(defmacro nlet (a)
  (subst-symbols '(letrec ((<name> (lambda <funvars> . <body>)))
                    (<name> . <funargs>))
                 '<name>    (cadr a)
                 '<body>    (cdddr a)
                 '<funvars> (mapcar car  (caddr a))
                 '<funargs> (mapcar cadr (caddr a))))

;; ;; For compatibility with the nlambda of the compiler
;; ;; COULD BECOME OBSOLETE IN FUTURE (or maybe not primitive from the compiler)
;; (unless (running-compiled?)
;;   (defmacro nlambda (a)
;;     (subst-symbols '(let ((<name> (lambda . <rest>)))

;; Poor mans symbol-macrolet right here. If I introduce lexical bindings this version of it
;; will be downright nasty. ONLY GOOD WITH DYNAMIC SCOPING
(defmacro symbol-macrolet (a) 
  (let ((generate-args (lambda (lst acc)
                         (if (end? lst)
                             acc
                             (generate-args (cdr lst) (list* (first (car lst)) (second (car lst)) acc))))))
    (list* 'progn (apply subst-symbols (cddr a) (generate-args (cadr a) nil)))))

;; TODO: have this macro replace setq's in body for putfs
(defmacro with-plist (a) 
  (subst-symbols '(symbol-macrolet <macrolet-args> . <body>)
                 '<macrolet-args> (mapcar (lambda (x)
                                            (subst-symbols '(<x> (getf <plist> '<x>))
                                                           '<x> x
                                                           '<plist> (caddr a)))
                                          (cadr a))
                 '<body> (cdddr a)))

;; FIXME: doesn't behave well on dotted lists
(defun last (lst)
  (if (end? (cdr lst))
      lst
      (last (cdr lst))))

;; (defun butlast! (lst . rst)
;;   (let ((roop (lambda (lst prev n)
;;                 (let ((x (nthcdr n lst)))
;;                   (if (end? x)
;;                       (rplacd prev nil)
;;                       (butlast! x lst n))))))
;;     (roop (nthcdr n lst) lst (if (first rst) (first rst) 1))
;;     lst))

(defun butlast! (lst . rst)
  (let ((n (if (first rst) (first rst) 1))
        (len (length lst)))
    (unless (<= len n)
      (rplacd (nthcdr (- (- len n) 1) lst) nil)
      lst)))

(defun butlast (lst . rst) (butlast! (copy-list lst) (first rst)))
             
(defun rotate-left (lst)
  ;; "Move the first element to the end of LIST."
  (append (cdr lst) (list (car lst))))

(defun rotate-left! (lst)
  ;; "Destructively move the first element to the end LIST."
  (let ((tail (cdr lst)))
    (if tail
        (progn
          (rplacd lst nil)
          (rplacd (last tail) lst)
          tail)
      lst)))

(defun rotate-right (lst)
  ;; "Move the last element to the front of LIST."
  (append (last lst) (butlast lst)))

(defun rotate-right! (lst)
  ;; "Destructively move the last element to the front of LIST."
  (unless (cdr lst) (return-from rotate-right! lst))
  (let ((last (last lst)))
    (rplacd last (butlast! lst))
    last))

(defun make-ring (size . initial-element)
  (let* ((initial-element (car initial-element))
         (ring (make-list size initial-element)))
    (rplacd (last ring) ring)))

(defun ring-length (ring)
  (if ring
      (let ((first-element (first ring)))
        (let ((roop (lambda (ring len)
                      (if (eq? (car ring) first-element)
                          len
                          (roop (cdr ring) (1+ len))))))
          (roop (cdr ring) 1)))
      0))

(defun char->string (ch) (make-string 1 ch))

;; TODO: allow otherwise only last?
;;       handle lists like (or 1 2 3 ...) (and 1 2 3 ...)
(defmacro case (a)
  (let ((var (cadr a))
        (lst (cddr a))
        (sym (gensym)))
    (let ((generate-ors-ands (lambda (lst acc)
                               (if (end? lst)
                                   (reverse acc)
                                   (generate-ors-ands (cdr lst) (cons (list 'eql? sym (list 'quote (car lst))) acc))))))
      (subst-symbols '(let ((<sym> <var>))
                        (cond . <body>))
                     '<sym> sym
                     '<var> var
                     '<body> (mapcar (lambda (x)
                                       (cond ((and (list? (car x)) (eq? (caar x) 'and)) (cons (cons 'and (generate-ors-ands (cdar x) nil)) (cdr x)))
                                             ((and (list? (car x)) (eq? (caar x) 'or))  (cons (cons 'or  (generate-ors-ands (cdar x) nil)) (cdr x)))
                                             ((eq? (car x) 'otherwise) (cons 't (cdr x)))
                                             (t (subst-symbols '((eql? <sym> '<comparison>) . <body>)
                                                               '<sym> sym ; works with both dynamic and lexical scoping (however not with static)
                                                               '<comparison> (car x)
                                                               '<body> (cdr x)))))
                                     lst)))))

;; (defmacro case (a)
;;   (let ((var (cadr a))
;;         (lst (cddr a))
;;         (sym (gensym)))
;;     (subst-symbols '(let ((<sym> <var>))
;;                       (cond . <body>))
;;                    '<sym> sym
;;                    '<var> var
;;                    '<body> (mapcar (lambda (x)
;;                                      (cond ((eq? (car x) 'otherwise) (cons 't (cdr x)))
;;                                            (t (subst-symbols '((eql? <sym> '<comparison>) . <body>)
;;                                                              '<sym> sym ; works with both dynamic and lexical scoping (however not with static)
;;                                                              '<comparison> (car x)
;;                                                              '<body> (cdr x)))))
;;                                    lst))))

(defun hash=  (a b) (=  (sxhash a) (sxhash b)))
(defun hash/= (a b) (/= (sxhash a) (sxhash b)))
(defun hash<  (a b) (<  (sxhash a) (sxhash b)))
(defun hash>  (a b) (>  (sxhash a) (sxhash b)))
(defun hash<= (a b) (<= (sxhash a) (sxhash b)))
(defun hash>= (a b) (>= (sxhash a) (sxhash b)))


;; Is this the basis for a merge sort? Only time will tell... (also: NOT TAIL RECURSIVE)
(defun merge (a b comparison)
  (cond ((end? a) b)
        ((end? b) a)
        ((comparison (car a) (car b)) (cons (car a) (merge (cdr a) b comparison)))
        (t                            (cons (car b) (merge a (cdr b) comparison)))))

(defun sort-list (lst . rst)
  ;; TODO: possible optimization?!: copy and count length at the same time
  (let ((comparison (if rst (car rst) <)))
    (%sort-list (copy-list lst) comparison (length lst))))

;; Sort lst (sort of destructively yet not in place and not without
;; allocating up a new list). Uses merge-sort. Helper function. Will
;; be called upon with a newly copied list so we don't have to feel so
;; very bad about destroying it.
;; TODO: rewrite me with a merge that has numbers for keeping track of
;; where in the list it is! Thus no splitting will be neccesary
(defun %sort-list (lst comparison len)
  (if (= len 1)
      lst
      (letrec ((lower-part (ash len -1))
               (upper-part (ash (1+ len) -1))
               (split (lambda (lst cntr)                ; This messes up the time-complexity of the algorithm by introducing an unnecesary linear portion. wee!
                        (if (< cntr lower-part)         ; mergesort isn't all that optimizsed for linked lists...
                            (split (cdr lst) (1+ cntr))
                            (let ((res (cdr lst)))
                              (rplacd lst nil) ; split lst
                              res))))
               (lst-upper (split lst 1)))
        (merge (%sort-list lst comparison lower-part)
               (%sort-list lst-upper comparison upper-part)
               comparison))))

;; Think unix command uniq. You got it!
(defun uniq (lst . rst)
  (let ((eq-fn (if rst (car rst) eql?))) ; default to comparing with eql?
    (letrec ((roop (lambda (lst acc)
                     (if (end? lst)
                         (reverse! acc)
                         (roop (cdr lst) (if (eq-fn (car acc) (car lst))
                                             acc
                                             (cons (car lst) acc)))))))
      (roop lst nil))))

(defun symbol-concat symbol-list
  (intern (with-output-to-string (*standard-output*)
            (call-for-list symbol-list prin1))))


(defun find-char (str ch)
  (nlet roop ((i 0))
    (if (char= (aref str i) ch)
        i
        (roop (1+ i)))))

(defun cut-string-at-char (str ch)
  (let* ((size (find-char str ch))
         (res (make-string size #\,)))
    (dotimes (i size)
      (aset res i (aref str i)))
    res))

    
(setq *features* nil)
(defun require (module)
  (unless (member module *features*)
    (rerequire module)))

(defun rerequire (module)
  (load (prin1-to-string (symbol-concat module '|.ljsp|)))) ; KLUDGE: replace me with proper string concatentation blahablaha

(defun provide (module)
  (unless (member module *features*)
    (push module *features*)))

(let ((a 1) (b 2)) (+ a b))
(let ((a 1) (b 2)) (cons a b #(hej din fisk (1 2 3))))

(let ((a 1) (b 2)) (cons a '(#\W (1231312312312312312312312312312313123 . 5343412914294967296) (<a> <b> <c>) b #(hej din fisk (1 2 3)) "potatismossa" . 12.4)))

(provide 'stuff)

;-*- Mode: Lisp -*-
;;;; java.ljsp

(require 'stuff)

;; Rack down the parenthesis-count a little...
(defun send (obj msg . args) (apply (obj msg) args))

(defun fetch-java-classes clazzes
  (let ((roop (lambda (lst)
                (unless (end? lst)
                  (set (car lst) (send Class 'forName (cadr lst)))
                  (roop (cddr lst))))))
    (roop clazzes)))

(fetch-java-classes 'Array               "java.lang.reflect.Array"
                    'Arrays              "java.util.Arrays"
                    'ArrayList           "java.util.ArrayList"
                    'String              "java.lang.String"
                    'StringBuilder       "java.lang.StringBuilder"
                    'HashMap             "java.util.HashMap"
                    'JFrame              "javax.swing.JFrame"
                    'JLabel              "javax.swing.JLabel"
                    'JPanel              "javax.swing.JPanel"
                    'JButton             "javax.swing.JButton"
                    'JFormattedTextField "javax.swing.JFormattedTextField"
                    'JTextField          "javax.swing.JTextField"
                    'JTextArea           "javax.swing.JTextArea"
                    'JPanel              "javax.swing.JPanel"
                    'JScrollPane         "javax.swing.JScrollPane"
                    'JList               "javax.swing.JList"
                    'JOptionPane         "javax.swing.JOptionPane"
                    'Box                 "javax.swing.Box"
                    'DefaultListModel    "javax.swing.DefaultListModel"
                    'javax.swing.Timer   "javax.swing.Timer"
                    'Thread              "java.lang.Thread"
                    'ActionEvent         "java.awt.event.ActionEvent"
                    'KeyEvent            "java.awt.event.KeyEvent"
                    'MouseEvent          "java.awt.event.MouseEvent"
                    'WindowEvent         "java.awt.event.WindowEvent"
                    'EventQueue          "java.awt.EventQueue"
                    'Color               "java.awt.Color"
                    'GridLayout          "java.awt.GridLayout"
                    'Graphics            "java.awt.Graphics"
                    'Graphics2D          "java.awt.Graphics2D"
                    'Toolkit             "java.awt.Toolkit"
                    'RoundRectangle2D    "java.awt.geom.RoundRectangle2D"
                    'RoundRectangle2D$Double "java.awt.geom.RoundRectangle2D$Double"
                    'RoundRectangle2D$Float "java.awt.geom.RoundRectangle2D$Float"
                    'Rectangle2D         "java.awt.geom.Rectangle2D"
                    'Rectangle2D$Double  "java.awt.geom.Rectangle2D$Double"
                    'Rectangle2D$Float   "java.awt.geom.Rectangle2D$Float"
                    'InputStream         "java.io.InputStream"
                    'FileInputStream     "java.io.FileInputStream"
                    'StringReader        "java.io.StringReader"
                    'Boolean             "java.lang.Boolean"
                    'Short               "java.lang.Short"
                    'Integer             "java.lang.Integer"
                    'Long                "java.lang.Long"
                    'Float               "java.lang.Float"
                    'Double              "java.lang.Double"
                    'Character           "java.lang.Character"
                    'Math                "java.lang.Math"
                    'Object              "java.lang.Object"
                    'HashSet             "java.util.HashSet"
                    'System              "java.lang.System"
                    'Font                "java.awt.Font"
                    'Runtime             "java.lang.Runtime"
                    'BigInteger          "java.math.BigInteger"

                    'Symbol              "org.starlisp.core.Symbol"
                    'Cell                "org.starlisp.core.Cell"
                    'Procedure           "org.starlisp.core.Procedure"
                    'LispSubr            "org.starlisp.core.LispSubr"
                    'LispStream          "org.starlisp.core.LispStream"
                    'LispException       "org.starlisp.core.LispException")

;; GURBER
(defun make-my-array lst
  (let* ((len (length lst))
         (idx 0)
         (ar (send Array 'newInstance Object len)))
    (dolist (l lst)
      (send Array 'set ar idx l)
      (inc idx))
    ar))

(defun java-array->list (ary)
  (let ((roop (lambda (cnt acc)
                (if (< cnt 0)
                    acc
                    (roop (1- cnt) (cons (send Array 'get ary cnt) acc))))))
    (roop (1- (send Array 'getLength ary)) nil)))

(defun print-methods (klas)
  (dolist (i (mapcar (lambda (x) (send x 'toString))
                     (java-array->list (send klas 'getMethods))))
    (write-string i)
    (terpri)))

(defun print-fields (klas)
  (dolist (i (mapcar (lambda (x) (send x 'toString))
                     (java-array->list (send klas 'getFields))))
    (write-string i)
    (terpri)))

                  
;; (defun instance-of (a b)
;;   (send  'isInstance b))

(defun field-value (obj field)
  (let ((field (if (send Symbol 'isInstance field)
                   (prin1-to-string field)
                   field))
        (klas (if (send Class 'isInstance obj)
                  obj
                  (send obj 'getClass))))
    (send (send klas 'getField field) 'get obj)))

;; Useful when you need to call several methods for side-effects on a single object,
;; like when using swing for example.
(defmacro with-object (a)
  (let ((obj-sym (gensym)))
    (subst-symbols '(let ((<obj-sym> <obj>))
                      (progn . <body>)
                      <obj-sym>)
                   '<obj-sym> obj-sym
                   '<obj>     (cadr a)
                   '<body>    (mapcar (lambda (x)
                                        (subst-symbols '(send <obj-sym> '<method> . <args>)
                                                       '<obj-sym> obj-sym
                                                       '<method>  (car x)
                                                       '<args>    (cdr x)))
                                      (cddr a)))))
                               

;; Java-adapted try-catch thingamajing. uses the low-level %try
;; Here we see when substitution-based macro-building is inferior to backquoting (which ljsp lacks at the moment)
(defmacro try-catch-finally (a)
  (let* ((rst (cdr a))
         (catch-forms (nlet collect ((lst rst) (acc nil))
                            (let ((x (member 'catch lst)))
                              (if (end? x)
                                  (reverse! acc)
                                  (collect (cdddr x) (cons (cons (second x) (third x)) acc))))))
         (exception-sym (gensym)))
    (print 'bajs)
    (subst-symbols '(%try (lambda () <try-form>)
                          (lambda (<exception-sym>) (cond . <cond-body>)))
                   '<exception-sym> exception-sym
                   '<try-form>      (second (member 'try rst))
                   '<cond-body>     (append
                                     (mapcar (lambda (_)
                                               (subst-symbols '((send <exception-type> 'isInstance <exception-sym>) (let ((<exception-name> <exception-sym>))
                                                                                                                      <handler-form>))
                                                              '<exception-type> (caar _)
                                                              '<exception-sym>  exception-sym
                                                              '<exception-name> (cadar _)
                                                              '<handler-form>   (cadr _)))
                                             catch-forms)
                                     (list (subst-symbols '(t <finally-form> (throw <exception-sym>))
                                                          '<finally-form> (second (member 'finally rst))
                                                          '<exception-sym> exception-sym))))))

    
;; ;; Wants to be replaced
;; (defun read-from-string (str)
;;   (let ((make-string-reader (send Array 'get (send StringReader 'getConstructors) 0))
;;         (make-lisp-stream (send Array 'get (send LispStream 'getConstructors) 1)))
;;     (read (send make-lisp-stream 'newInstance (make-my-array (send make-string-reader 'newInstance (make-my-array str)) nil)))))





;; ;; MEGAUGLY
;; (let ((tmp (send ArrayList 'newInstance)))
;;   (setq java-true (send tmp 'add 23))
;;   (setq java-false (send tmp 'contains 22)))

;; Some playing around
(setq fib-memo-arraylist (send ArrayList 'newInstance))
(let ((add (fib-memo-arraylist 'add)))
  (add 0)
  (add 1)
  (dotimes (i 3000) (add -1)))
(defun fib-memo-java (n)
  (let ((tjo (send fib-memo-arraylist 'get n)))
    (if (/= tjo -1)
        tjo
        (let ((result (+ (fib-memo-java (- n 1)) (fib-memo-java (- n 2)))))
          (send fib-memo-arraylist 'set n result)
          result))))

(defun hello-warld ()
  (setq frame (send JFrame 'newInstance)
        label (send JLabel 'newInstance))
  (send frame 'setTitle "HelloWorldSwing")
  (send label 'setText "Hello World")
  (send (send frame 'getContentPane) 'add label)
  (send frame 'pack)
  (send frame 'setVisible t))

;; (setq newline "
;; ")
;; (setq char-newline #\
;;       )      

(defun start-listener ()
  (setq listener (list 'frame              (send JFrame 'newInstance)
                       'text-field         (send JTextField 'newInstance)
                       'text-area          (send JTextArea 'newInstance)
                       'output-scroll-pane (send JScrollPane 'newInstance)
                       'list-scroll-pane   (send JScrollPane 'newInstance)
                       'symbol-list        (send JList 'newInstance)
                       'panel              (send Box 'createHorizontalBox) ;(send JPanel 'newInstance)
                       'right-box          (send Box 'createVerticalBox)
                       'history            nil
                       'history-tmp        nil))
  (with-plist (frame
               text-field
               text-area
               output-scroll-pane
               list-scroll-pane
               symbol-list
               panel
               right-box) listener
    (with-object text-field
      (setText "Write stuffs here for great justice!")
      (setColumns 24)
      (addActionListener
       (make-listener (lambda (e)
                        (send text-area 'append
                              (with-output-to-string (*standard-output*)
                                (let* ((str         (send e 'getActionCommand))
                                       (what-i-read (read-from-string str)))
                                  (write-char #\>) (write-char #\>) (write-char #\ ) ;FIXME: GARH
                                  (print what-i-read)
                                  (print (eval what-i-read))
                                  (putf listener 'history (cons str (getf listener 'history))))))
                        (send text-field 'setText "")
                        (listener-update-symbol-list))))
      (addKeyListener
       (make-listener (lambda (e)
                        (when (= (send e 'getID) (field-value KeyEvent 'KEY_PRESSED))
                          (unless (getf listener 'history-tmp) (putf listener 'history-tmp (copy-list (getf listener 'history))))
                          (cond ((= (send e 'getKeyCode) (field-value KeyEvent 'VK_UP))
                                 (send text-field 'setText (car (getf listener 'history-tmp)))
                                 (putf listener 'history-tmp (rotate-left (getf listener 'history-tmp))))
                                ((= (send e 'getKeyCode) (field-value KeyEvent 'VK_DOWN))
                                 (send text-field 'setText (car (getf listener 'history-tmp)))
                                 (putf listener 'history-tmp (rotate-right (getf listener 'history-tmp))))
                                (t (putf listener 'history-tmp nil))))))))
    (with-object text-area
      (setRows 24)
      (setColumns 72)
      (setEditable nil)
      (setLineWrap t)
      (setAutoscrolls t))
    (send output-scroll-pane 'setViewportView text-area)
    (with-object symbol-list
      (setFixedCellWidth 128)
      (addKeyListener
       (make-listener (lambda (e)
                        (and (= (send e 'getID)      (field-value KeyEvent 'KEY_PRESSED))
                             (= (send e 'getKeyCode) (field-value KeyEvent 'VK_ENTER))
                             (send text-field 'setText
                                   (prin1-to-string (send symbol-list 'getSelectedValue))))))))
    (listener-update-symbol-list)
    (send list-scroll-pane 'setViewportView symbol-list)
    (with-object right-box
      (add output-scroll-pane)
      (add text-field))
    (with-object panel
      (add list-scroll-pane)
      (add right-box))
    (with-object frame
      (setTitle "Listener")
      (setDefaultCloseOperation (field-value JFrame 'DISPOSE_ON_CLOSE))
      (add panel)
      (pack)
      (setVisible t))))

(defun get-procedure-list ()
  (remove-if (lambda (x)
               (cond  ((send LispSubr 'isInstance (symbol-value x)) nil)
                      ((atom? (symbol-value x)) t)
                      ((eq? (car (symbol-value x)) 'lambda) nil) 
                      ((eq? (car (symbol-value x)) 'macro)  nil)
                      (t t)))
             (symbols)))

(defun listener-update-symbol-list ()
  (send (getf listener 'symbol-list) 'setListData
        (apply make-my-array (get-procedure-list))))

(provide 'java)
;-*- Mode: Lisp -*-

;;; IDEA: (doesn't really belong here?) Start having fexprs (or
;;; similar) so you can be meaner in how you handle macros (as
;;; statically as CL for instance).

;;; Can you somehow coerce the JVM into thinking duck-typing is a good idea? 

;; TODO: DONE-ish add argument to pretty much everything to keep track of tail-call or not
;;       * Judicious finals everywhere (we don't subclass the generated classes after all)
;;       * Perhaps move classname out of the environment plist?
;;       * More correct-amount-of-args-checking and the likes
;;       * Make all environtment be ONE environment and convey static/lexical/dynamic using the plist instead?!?!?
;;       * instead of having the creepy %literal-vars% and %literal-init% type variables scan code ahead of
;;         time to generate a table of constants? (we don't win much on this move except
;;         having cleaner code with less side-effects


(require 'java)

;; Perhaps move this to stuff.ljsp due to it's bootstrappinessishness?
(unless (running-compiled?)
  (defmacro defvar (a)
    (unless (symbol-value (cadr a))     ; unless already bound
      (list 'setq (cadr a) (caddr a)))))


;; FOR NOW
(defvar cfib '(nlambda fib (n) (if (= n 0) 0 (if (= n 1) 1 (+ (fib (- n 1)) (fib (- n 2)))))))

(defvar cfib-trec '(lambda (n)
                     ((nlambda calc-fib (n a b)
                        (if (= n 0)
                            a
                            (calc-fib (- n 1) b (+ a b))))
                      n 0 1)))

(defvar fcollatz '(nlambda collatz (n) (print n) (if (= n 1) nil (collatz (if (= (mod n 2) 0) (/ n 2) (+ 1 (* n 3)))))))

;; differs semantically slightly from the mapcar1 in stuff.ljsp (aside from wierd binding-stuffs, it doesn't use end? for end of list)
(defvar mopcor1 '(nlambda mapcar1 (fnx lstx) (if lstx (cons (fnx (car lstx)) (mapcar1 fnx (cdr lstx))) nil)))

;; differs semantically slightly from the assq in stuff.ljsp (aside from wierd binding-stuffs, it doesn't use end? for end of list)
;; left some crud in ((lambda nil nil)) (from macro expansion), for testing, in it but removed others that wouldn't work in static scoping...
(defvar cassq '(nlambda assq (key alist) (if (eq? alist nil) ((lambda nil nil)) (if (eq? key (car (car alist))) (car alist) (assq key (cdr alist))))))

(defvar quote-test (subst-symbols
                    '(lambda (a)
                      (cons a '(#\W (1231312312312312312312312312312313123 . 5343412914294967296) (<a> <b> <c>) b #(hej din fisk (1 2 3)) "potatismossa" . 12.4)))
                    ;; since the current reader has no syntax for introducing NaN's we do this. the compiler needs to handle it
                    ;; after all and maybe the reader supports some syntax for NaN in the future
                    '<a> (/ 0.0 0.0)
                    '<b> (/ 1.0 0.0)    ; same for pos inf
                    '<c> (/ 1.0 -0.0)))  ; same for neg inf

(defvar cfact '(nlambda fact (n acc) (if (= 0 n) acc (fact (- n 1) (* n acc)))))

;; Blargh my parser is broken in many strange ways and crazy so let's
;; have a crazy variable for this
(defvar dblfnutt (prin1-to-string '|"|))

(defvar nl "
")

(defvar *compiled-body* '())

(defvar *dynamic-variables* '())

(defvar *label-counter* 0)
(defvar *funclabel-counter* 0)
(defvar *static-var-counter* 0)

;; These are dynmic variables locally overrided to contain
;; initializing code, and the static variable definitions for all the
;; literals, into their static variables, for the currently compiling
;; class file. Defvarring them like this makes them be SPECIAL (or whatever)
(defvar %literal-init% nil)
(defvar %literal-vars% nil)

;; local variables 5 and above are for static environment. 0 to 5 have
;; special uses. With 0 always referring to the this variable. 3 being
;; a temp variable and the others are for the time being undefined.
(defvar +reserved-regs-split+ 5)

(defun get-label ()
  (concat "L" (inc *label-counter*)))

(defun get-funclabel ()
  (concat "FUN" (inc *funclabel-counter*)))

(defun get-static-var-name ()
  (concat "lit" (inc *static-var-counter*)))



;;;; Functions implemented using java classes that perhaps should be
;;;; made built-in to ease boot-strapping and portability

;; For portabilitys sake consider makeing this a built in subr
(defun concat strs
  (let ((sb (send StringBuilder 'newInstance)))
    (dolist (str strs)
      (send sb 'append str))
    (send sb 'toString)))

;; Same: for portabilitys sake consider making this built in or similar
(defun load-proc (name)
  (let ((name (if (type? 'symbol name) (prin1-to-string name) name)))
    (send (send Class 'forName name) 'newInstance)))

(defun concat-nl strs
  (apply concat (flatten (mapcar (lambda (x) (list x nl)) strs))))

(defun NaN? (a)
  (send Double 'isNaN a))

(defun infinite? (a)
  (send Double 'isInfinite a))

;;;; End functions using java


;;;; CODE WALKER FOR LEXICAL ANALYSIS
;;;; Used to find free variables in lambdas (and macros) mainly 
;; This here thing does NOT want code with macros in it (HINT:
;; remember to expand macros way early) (just think about the
;; confusion let would be, for instance). Also think about: local
;; macros WTF?

(defun analyze (a . rst)
  (let ((local-variables (car rst)))
    (uniq (sort-list (analyze-expr a local-variables) hash<) eq?)))
    

(defun analyze-expr (a local-variables)
  (if (atom? a)
      (if (and (type? 'symbol a)
               (not (member a local-variables))
               (not (member a *dynamic-variables*)))
          (list a)
          '())
      (case (car a)
        (quote '())          ; no variables can be captured in a quote
        (lambda (analyze-lambda a local-variables)) ; macro?
        (if (analyze-list a local-variables))       ; Treat if specially in future? (is there a point in closing over the VARIABLE if ?)
        (otherwise (analyze-list a local-variables)))))

(defun analyze-lambda (a local-variables)
  (unless (eq? (car a) 'lambda)         ; macro?
    (error "You ought to supply me with a lambda when you want to analyze free variables in a lambda."))
  (letrec ((scan (lambda (lst acc)
                   (cond ((null? lst) (reverse! acc))
                         ((atom? lst) (reverse! (cons lst acc)))
                         (t (scan (cdr lst) (cons (car lst) acc)))))))
    (analyze-list (cddr a) (append (scan (cadr a) nil) local-variables))))

(defun analyze-list (a local-variables)
  (letrec ((roop (lambda (lst acc)
                   (if (end? lst)
                       acc
                       (roop (cdr lst) (append acc (analyze-expr (car lst) local-variables)))))))
    (roop a nil)))

;; Remember to check if there are too many arguments as well in things like if and print

(defun emit-if (a e tail)
  (let ((condition (cadr a))
        (true-expr (caddr a))
        (false-expr (cadddr a))
        (label (get-label))
        (label-after (get-label)))
    (concat ";; " a nl
            (emit-expr condition e nil)
            "ifnonnull " label " ; branches to the true-expr" nl
            (emit-expr false-expr e tail)
            "goto " label-after " ; Don't also run the true-expr like a fool" nl
            label ":" nl
            (emit-expr true-expr e tail)
            label-after ":" nl
            ";; endif" nl)))

;;;; Used by emit-funcall to generate code for how to structure arguments before the actual call
;;;; This particular version is when passing arguments in an array
(defun emit-funargs (args e)
  (letrec ((roop (lambda (lst e cntr asm)
                   (if (end? lst)
                       asm
                       (roop (cdr lst)
                             e
                             (1+ cntr)
                             (concat asm
                                     "dup"                        nl
                                     "ldc_w " cntr                nl
                                     (emit-expr (car lst) e nil)
                                     "aastore"                    nl))))))
    (let ((len (length args)))
      (if (zero? len)
          (concat "aconst_null" nl) ; very slight optimization of the no-argument case
          (concat "ldc_w " len           nl
                  "anewarray LispObject" nl
                  (roop args e 0 ""))))))


;; Version for passing arguments on stack in regular order
#;(defun emit-funargs (args e)
  (if args
      (apply concat (mapcar (lambda (x) (emit-expr x e nil)) args)))
      "")

;; This will need to do different things for a non-compiled function a
;; compiled function a compiled or non-compiled macro according to
;; their current bindings (we fearlessly ignore that for the
;; dynamically scoped case our function bindings might change and
;; such. This is less a problem in the lexically scoped case yet still
;; a problem for some cases (which cases?))
;; WHEN JSR-ing (or similar):
;; Don't forget to reverse the arglist
;; Don't forget to push local vars....
;; TODO: Think up ways to store variables together with some sort of type data so we know when to do what funcall

;; POSSIBLE OPTIMIZATION: Inline in a nice way when just a regular
;; non-recursive lambda-thingy (like the case the let- or progn macro
;; would generate (especially the latter one is trivial))
(defun emit-funcall (a e tail)
  (let ((fun (car a))
        (args (cdr a)))
    (if (and tail
             (type? 'symbol fun)
             (print (get-variable-property fun 'self e)))
        (emit-self-recursive-tail-call args e)
        (concat ";; " a                    nl
                (emit-expr fun e nil)           ; puts the function itself on the stack
                "checkcast Procedure"      nl
                "; preparing args"         nl
                (emit-funargs args e)
                "; end preparing args"     nl
                "invokevirtual Procedure.run([LLispObject;)LLispObject;" nl))))

;; WRITTEN FOR STATIC ONLY
;; TODO: rewrite when stuff changes...
;; This currently assumes a certain layout of variables laid out by emit-lambda-body.
;; Note how we just reuse the old state locations since a tail-call let's us discard the old state for this frame entirely
;; However: Before we start setting the local variables we have pushed all the results to the stack.
;; If we didn't all sorts of side-effect mayhem might occur for example for
;; (nlambda foo (a b) (if (> a 100) a (foo (+ a 2) (* a b)))) a is used twice in the argument list
(defun emit-self-recursive-tail-call (args e)
  (letrec ((funargs-push (lambda (lst e asm)
                           (if (end? lst)
                               asm
                               (funargs-push (cdr lst)
                                             e
                                             (concat asm
                                                     (emit-expr (car lst) e nil))))))
           (funargs-pop (lambda (cntr offset asm)
                          (if (zero? cntr)
                              asm
                              (funargs-pop (1- cntr)
                                           offset
                                           (concat asm
                                                   "astore " (+ (1- cntr) offset) nl))))))
    (concat ";; self-recursive tail-call args: " args nl
            (funargs-push args e "")
            (funargs-pop (length args) +reserved-regs-split+ "")
            "goto Lselftail" nl)))

(defun emit-quote (a e)
  (unless (and (eq? (car a) 'quote)
               (= (length a) 2))
    (error (concat "Something's wrong with your quote: " a)))
  (unless (and (type? 'string %literal-init%)  ; compile-lambda does initialize these to "", 
               (type? 'string %literal-vars%)) ; so they should always be strings when we end up here
    (error (concat "Special variables %literal-vars%: " (prin1-to-string %literal-vars%)
                   " and %literal-init%: " (prin1-to-string %literal-init%)
                   " not properly initialized")))
  (let ((static-var (get-static-var-name))
        (classname  (getf e 'classname)))
    (setq %literal-vars% (concat %literal-vars%
                                 ".field private static final " static-var " LLispObject;" nl))
    (setq %literal-init% (concat %literal-init%
                                 (emit-obj (second a) e)
                                 "putstatic " classname "/" static-var " LLispObject;"))
    (concat "getstatic " classname "/" static-var " LLispObject;" nl)))

(defun emit-java-double (a)
  (cond ((NaN? a)
         ;; KLUDGE: workaround using division by zero (resulting in NaN) since
         ;; jasmin seems to have trouble, or at least is lacking any documention,
         ;; how to load a NaN double as a constant
         (concat ";; jasmin lacks all sort of documentation on how to push a NaN double. Division by zero works as a work-around." nl
                 "dconst_0" nl
                 "dconst_0" nl
                 "ddiv"     nl))
        ((and (infinite? a) (not (neg? a)))
         ;; KLUDGE: same thing but for positive infinity
         (concat ";; hackaround for positive infinity" nl
                 "ldc2_w 1.0d" nl
                 "dconst_0"    nl
                 "ddiv"        nl))
        ((and (infinite? a) (neg? a))
         ;; KLUDGE: same thing but for negative infinity
         (concat ";; hackaround for negative infinity" nl
                 "ldc2_w -1.0d" nl
                 "dconst_0"     nl
                 "ddiv"         nl))
        (t
         ;; that d is important, otherwise we are loading a float (not double)
         ;; constant and introducing rounding errors
         (concat "ldc2_w " a "d" nl))))

(defun emit-java-long (a)
  (concat "ldc2_w " a nl))

;; Emits code to regenerate an object as it is (quoted stuffs use
;; this)
;; TODO: * what about procedures and the like, while not having a
;;         literal representation one might send crazy shit to the
;;         compiler...?
;;       * What about uninterned symbols? (Does it really make a difference?) Very tricky shit this :/
(defun emit-obj (obj e)
  (cond ((eq? obj nil) (emit-nil))
        ((type? 'fixnum obj)
         (concat "new LispFixnum" nl
                 "dup"            nl
                 (emit-java-long a)
                 "invokenonvirtual LispFixnum.<init>(J)V" nl))
        ((type? 'flonum obj)
         (concat "new LispFlonum" nl
                 "dup"            nl
                 (emit-java-double obj)
                 "invokenonvirtual LispFlonum.<init>(D)V" nl))
        ((type? 'bignum obj)
         (concat "ldc_w " dblfnutt obj dblfnutt nl
                 "invokestatic LispBignum.parse(Ljava.lang.String;)LLispBignum;" nl))
        ((type? 'string obj)
         (concat "new LispString"                  nl
                 "dup"                             nl
                 "ldc_w " dblfnutt obj dblfnutt    nl
                 "invokenonvirtual LispString.<init>(Ljava.lang.String;)V" nl))
        ((type? 'array obj)
         (concat "new LispArray"                   nl
                 "dup"                             nl
                 (nlet roop ((cntr (length obj))
                             (asm (concat "ldc_w " (length obj)  nl
                                          "anewarray LispObject" nl)))
                   (if (zero? cntr)
                       asm
                       (roop (1- cntr)
                             (concat asm
                                     "dup"                                nl
                                     "ldc_w " (1- cntr)                   nl
                                     (emit-obj (aref obj (1- cntr)) e)
                                     "aastore"                            nl))))
                 "invokenonvirtual LispArray.<init>([LLispObject;)V" nl))
        ((type? 'symbol obj)
         (concat "ldc_w " dblfnutt obj dblfnutt nl
                 "invokestatic Symbol.intern(Ljava.lang.String;)LSymbol;" nl))
        ((type? 'char obj)
         (concat "new LispChar"                  nl
                 "dup"                           nl
                 "bipush " (char->integer obj)   nl
                 "invokenonvirtual LispChar.<init>(C)V" nl))
        ((type? 'cons obj)
         (concat "new Cons"                nl
                 "dup"                     nl
                 (emit-obj (car obj) e)
                 (emit-obj (cdr obj) e)
                 "invokenonvirtual Cons.<init>(LLispObject;LLispObject;)V" nl))
        (t (error (concat "Couldn't match type for:" a)))))
                 
(defun emit-return-self (obj e)
  (cond ((type? 'symbol obj) (emit-variable-reference obj e))
        ((atom? obj)         (emit-obj obj e))
        (t (error "Arghmewhats?"))))



;; TODO: when/if removing multiple alists for different sorts of environments: REWRITE
;; THIS IS REALLY A HUGE KLUDGE
(defun get-variable-property (var property e)
  (or (get-static-variable-property var property e)
      (get-lexical-variable-property var property e)
      (get-dynamic-variable-property var property e)))

(defun get-static-variable-property (var property e)
  (getf (cddr (assq var (getf e 'static-environment))) property))

(defun get-lexical-variable-property (var property e)
  (getf (cddr (assq var (getf e 'dynamic-environment))) property))

(defun get-dynamic-variable-property (var property e)
  (getf (cddr (assq var (getf e 'lexical-environment))) property))
      

;;;; Variable lists look like ((a <storage-location> . <extra-properties-plist>) (b ...) ...)
;;;; e.g ((a 1) (fib 0 self t))
(defun get-static-variable (var e)
  (let ((static-environment (getf e 'static-environment)))
    (cadr (assq var static-environment))))

(defun get-lexical-variable (var e)
  (let ((lexical-environment (getf e 'lexical-environment)))
    (cadr (assq var lexical-environment))))

(defun get-dynamic-variable (var e)
  (let ((dynamic-environment (getf e 'dynamic-environment)))
    (cadr (assq var dynamic-environment))))

(defun emit-variable-reference (a e)
  (let ((static-var-place  (get-static-variable a e))
        (lexical-var-place (get-lexical-variable a e))
        (dynamic-var-place (get-dynamic-variable a e)))
    (cond (static-var-place (concat "aload " static-var-place nl))
          (lexical-var-place (concat "nolexicalyet" nl))
          (dynamic-var-place (concat "nodynamicyet" nl))
          (t (error (concat "Variable: " a " doesn't seem to exist anywhere."))))))

(defun emit-arithmetic (a e)
  (unless (= (length a) 3)
    (error (concat "You can't arithmetic with wrong amount of args: " a)))
  (concat (emit-expr (second a) e nil)
          "checkcast LispNumber" nl
          (emit-expr (third  a) e nil)
          "checkcast LispNumber" nl
          "invokevirtual LispNumber."
          (case (car a) (+ "add") (- "sub") (* "mul") (/ "div"))
          "(LLispNumber;)LLispNumber;" nl))

(defun emit-integer-binop (a e)
  (unless (= (length a) 3)
    (error (concat "You can't integer-binop with wrong amount of args: " a)))
  (concat (emit-expr (second a) e nil)
          "checkcast LispInteger" nl
          (emit-expr (third  a) e nil)
          "checkcast LispInteger" nl
          "invokevirtual LispInteger."
          (case (car a) (mod "mod") (ash "ash"))
          "(LLispInteger;)LLispInteger;" nl))


;; Used, internalish, to emit dereferencing the variable t (currently special hardcoded, put in own function for modularity
(defun emit-t (e)
  (let ((classname (getf e 'classname)))
    (concat "getstatic " classname "/t LLispObject;" nl))) ; TODO: in the future try to emit a variable reference to t here instead of this hardcoded mishmash

;; Used to emit the sequence to convert a java boolean to a more lispish boolean. Used in mostly "internalish" ways.
(defun emit-boolean-to-lisp (e)
  (let ((label (get-label))
        (label-after (get-label)))
    (concat "ifeq " label nl
            ;; (emit-return-self 123 nil)    ; TODO: change me to emit t later
            (emit-t e)
            "goto " label-after nl
            label ":"           nl
            (emit-nil)
            label-after ":"     nl)))
  
(defun emit-= (a e)
  (unless (= (length a) 3)
    (error (concat "You can't = with wrong amount of args: " a)))
  (concat (emit-expr (second a) e nil)
          ;; "checkcast LispNumber" nl
          (emit-expr (third a)  e nil)
          ;; "checkcast LispNumber" nl
          "invokevirtual java/lang/Object.equals(Ljava/lang/Object;)Z" nl
          (emit-boolean-to-lisp e)))

(defun emit-neg? (a e)
  (unless (= (length a) 2)
    (error (concat "You can't neg? with wrong amount of args: " a)))
  (concat (emit-expr (second a) e nil)
          "checkcast LispNumber"             nl
          "invokevirtual LispNumber.negP()Z" nl
          (emit-boolean-to-lisp e)))

(defun emit-eq? (a e)
  (unless (= (length a) 3)
    (error (concat "You can't eq? with wrong amount of args: " a)))
  (let ((label-ne (get-label))
        (label-after (get-label)))
    (concat (emit-expr (second a) e nil)
            (emit-expr (third a)  e nil)
            "if_acmpne " label-ne    nl
            (emit-t e)
            "goto "      label-after nl
            label-ne ":"             nl
            "aconst_null"            nl
            label-after ":"          nl)))

(defun emit-eql? (a e)
  (error "eql? not implemented"))

;; TODO: * two-argument version of print
;;       * implement without temp variable if possible. Having
;;         temp-variables might grow trickier when some method
;;         implementations do away with the need to (always)
;;         deconstruct an array
(defun emit-print (a e)
  (let ((label-nil   (get-label))
        (label-after (get-label)))
    (concat ";; " a                                                          nl
            "getstatic java/lang/System/out Ljava/io/PrintStream;"           nl
            (emit-expr (cadr a) e nil)
            "dup"                                                            nl
            "astore_2 ; store in the temp variable"                          nl
            "dup"                                                            nl
            "ifnull " label-nil                                              nl
            "invokevirtual java/lang/Object.toString()Ljava/lang/String;"    nl
            "goto " label-after                                              nl
            label-nil ":"                                                    nl
            "pop"                                                            nl
            "ldc_w " dblfnutt "nil" dblfnutt                                 nl
            label-after ":"                                                  nl
            "invokevirtual java/io/PrintStream.println(Ljava/lang/String;)V" nl
            "aload_2 ; we return what we got"                                nl)))

(defun emit-set (a e)
  (error "set not implemented"))

(defun emit-nil ()
  (concat "aconst_null" nl))

(defun emit-car-cdr (a e)
  (unless (= (length a) 2)
    (error "You can't " (car a) " with wrong amount of args: " a))
  (let ((label-nil (get-label)))
    (concat (emit-expr (cadr a) e nil)
            "dup"                                    nl
            "ifnull " label-nil                      nl
            "checkcast Cons"                         nl
            "getfield Cons/" (car a) " LLispObject;" nl
            label-nil ":"                            nl)))

(defun emit-cons (a e)
  (unless (= (length a) 3)
    (error "You can't cons with wrong amount of args: " a))
  (concat "new Cons"                                                nl
          "dup"                                                     nl 
          (emit-expr (second a) e nil)
          (emit-expr (third a)  e nil)
          "invokenonvirtual Cons.<init>(LLispObject;LLispObject;)V" nl))
    
(defun emit-expr (a e tail)
  (if (list? a)
      (case (car a)
        ;; To be able to pass these, where appropriate (e.g: not if), as arguments the bootstrap code needs to define functions that use these builtins. e.g: (defun + (a b) (+ a b))
        ;; (running-compiled? (emit-return-self 1337 nil)) ; TODO: change me to emit t later
        (running-compiled? (emit-t e)) 
        (set      (emit-set a e))
        (eq?      (emit-eq? a e))
        (eql?     (emit-eql? a e))
        ((or + - * /) (emit-arithmetic a e))
        (=        (emit-= a e))
        (neg?     (emit-neg? a e))
        ((or mod ash) (emit-integer-binop a e))
        ((or car cdr) (emit-car-cdr a e))
        (cons         (emit-cons a e))
        (if (emit-if a e tail))
        (print (emit-print a e))
        ((or lambda nlambda) (emit-lambda a e))
        (quote (emit-quote a e)) 
        (otherwise (if (car a)          ; need to be careful about nil....? (should this truly be here?... well it is due to the list? check (nil is a list))
                       (emit-funcall a e tail)
                       (emit-nil))))
      (emit-return-self a e)))


(defun emit-lambda (a e)
  (let ((function-class-name (compile-lambda a
                                             (list 'static-environment  nil
                                                   'lexical-environment (getf e 'lexical-environment)
                                                   'dynamic-environment (getf e 'dynamic-environment)))))
    ;; TODO: save this in a private static final field in the class? (if
    ;; possible of course since when I introduce closures there will be cases
    ;; where it may no longer be possible to do it that way)
    (concat "new " function-class-name                           nl
            "dup"                                                nl
            "invokenonvirtual " function-class-name ".<init>()V" nl)))
            

;; OLD CRAP COMMENT?
;; TODO?: something else than compile-lambda should output whatever amounts to
;; dereferencing a function after actually having compiled the function and
;; stored it in an appropriate global var (otherwise we would get some strange
;; form of inline call wherever a lambda is)

(defun emit-classfile-prologue (classname)
  (concat ".class " classname "
.super Procedure

.field private static final t LLispObject;
" %literal-vars% "

.method static <clinit>()V
    .limit locals 255
    .limit stack 255

    ldc_w " dblfnutt "t" dblfnutt "
    invokestatic Symbol.intern(Ljava/lang/String;)LSymbol;
    putstatic " classname "/t LLispObject;
    " %literal-init% "
    return
.end method

.method public <init>()V
    .limit stack 2
    .limit locals 1

    aload_0
    ldc " dblfnutt classname dblfnutt "
    invokenonvirtual Procedure.<init>(Ljava/lang/String;)V
    return
.end method

.method public run([LLispObject;)LLispObject;
.limit stack  255
.limit locals 255
"))

(defun emit-classfile-epilogue (classname)
  (concat ".end method" nl))

;; Compile a lambda/nlambda in environment e. Store jasmin source in classname.j (if supplied, optional argument)
(defun compile-lambda (a e . rst)
  (unless (and (type? 'list a)
               (or (eq? (car a) 'lambda)
                   (eq? (car a) 'nlambda)))
    (error (concat "Are you really sure you passed me a lambda: " a)))
  (let* ((classname (if rst (car rst) (get-funclabel)))
         (env (list* 'classname classname e))
         (%literal-vars% "")
         (%literal-init% "")
         (body (case (car a)                            ; since we evaluate the body also for the side effects to %literal-vars% 
                 (lambda  (emit-lambda-body  a env))    ; and %literal-init% we have to evaluate this before emit-classfile-prologue
                 (nlambda (emit-nlambda-body a env)))))
    (with-open-file (stream (concat classname ".j") out)
      (write-string (concat (emit-classfile-prologue classname)
                            body
                            (emit-classfile-epilogue classname))
                    stream))
    ;; HERE: compile the file just emitted too
    classname))

(defun emit-progn (a e tail)            ; NOT TAIL RECURSIVE
  (cond ((cdr a) (concat (emit-expr (car a) e nil)
                         "pop" nl
                         (emit-progn (cdr a) e tail)))
        (a (emit-expr (car a) e tail))
        (t "")))
  
;; (nlambda <name> (a b c) . <body>)
(defun emit-nlambda-body (a e)
  (emit-lambda-body (cons 'lambda (cddr a))
                    e
                    ;; we know ourselves by being register 0 which is "this" in Java.  this variable
                    ;; has the self property set to the parameter-list of the function. emit-funcall
                    ;; will thus know it can do self-tail-call-elimination and also how the
                    ;; parameters are to be interpreted (when to construct a list out of some of
                    ;; them etc. etc.)
                    (acons (cadr a) (list 0 'self (third a)) nil)))

(defun emit-lambda-body (a e . rst)
  (letrec ((static-environment-augmentation (first rst)) ; Optional argument that augments the generated static environment if present
           (args (cadr a))
           (body (cddr a))
           (args-roop (lambda (lst alist asm cntr offset) ; TODO: variable arity rest-parameter stuff
                        (if lst
                            (args-roop (cdr lst)
                                       (acons (car lst) (list (+ cntr offset) 'static t) alist)
                                       (concat asm
                                               "aload_1"                 nl
                                               "ldc_w " cntr             nl
                                               "aaload"                  nl
                                               "astore " (+ cntr offset) nl)
                                       (1+ cntr)
                                       offset)
                            (cons asm alist))))
           (args-result (args-roop args '() "" 0 +reserved-regs-split+)) ; +reserved-regs-split+ is the first register that is general-purposey enough
           (asm (car args-result))
           (alist (cdr args-result))
           (new-e (list 'classname (getf e 'classname) 'static-environment (append alist static-environment-augmentation))))
    (concat ";; " a nl
            asm
            "Lselftail:" nl              ; label used for self-tail-recursive purposes
            (emit-progn body new-e t)    ; in a lambda the progn body is always a taily-waily
            "areturn"      nl
            ";; endlambda" nl))) 


;; An emit lambda for when all arguments are passed to the method
;; plain. Might be good if you want to kawa-style optimize when
;; there's a smaller than N number of args to a function
;; (defun emit-lambda (a e . rst)
;;   (letrec ((static-environment-augmentation (car rst)) ; Optional argument that augments the generated static environment if present
;;            (args (cadr a))
;;            (body (cddr a))
;;            (args-roop (lambda (lst alist cntr)
;;                         (if lst
;;                             (args-roop (cdr lst)
;;                                        (acons (car lst) cntr alist)
;;                                        (1+ cntr))
;;                             alist)))
;;            (new-e (list 'classname (getf e 'classname) 'static-environment
;;                         (append (args-roop args '() 1) ; 0 is the very special "this" argument, we don't want to include it here
;;                                 static-environment-augmentation))))
;;     (concat ";; " a nl
;;             (emit-progn body new-e t)    ; in a lambda the progn body is always a taily-waily
;;             "areturn"      nl
;;             ";; endlambda" nl)))

;; TODO: lexical i guess
;; Old emit lambda when i was preparing for JSR-based stuff (might come in handy again when you try your hand at TCO)
;; (defun emit-lambda (a e . rst)
;;   (letrec ((static-environment-augmentation (car rst)) ; Optional argument that augments the generated static environment if present
;;            (args (cadr a))
;;            (body (cddr a))
;;            (args-roop (lambda (lst asm alist cntr)
;;                         (if lst
;;                             (args-roop (cdr lst)
;;                                        (concat "astore " cntr nl asm)
;;                                        (acons (car lst) cntr alist)
;;                                        (1+ cntr))
;;                             (cons asm alist))))
;;            (args-result (args-roop args "" '() +reserved-regs-split+)) ; +reserved-regs-split+ is the first register that isn't reserved
;;            (asm (car args-result))
;;            (new-e (list 'classname (getf e 'classname) 'static-environment (append (cdr args-result) static-environment-augmentation))))
;;     (concat ";; " a nl
;;             "astore 255     ; store return address in variable 255" nl
;;             asm                          ; the argsy stuff
;;             (emit-progn body new-e t)    ; in a lambda the progn body is always a taily-waily
;;             "ret 255"      nl
;;             ";; endlambda" nl)))



(provide 'compile)

(exit)


